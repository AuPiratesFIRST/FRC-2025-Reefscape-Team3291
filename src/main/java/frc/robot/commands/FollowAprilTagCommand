package frc.robot.commands;

import com.limelightvision.limelight.frc.LimelightHelpers;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.MathUtil;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.SwerveSubsystem;

public class FollowAprilTagCommand extends CommandBase {
    private final SwerveSubsystem swerveDrive;
    private final String limelightName = "limelight-front"; // Adjust if needed

    private static final double kP_translation = 0.5;
    private static final double kP_rotation = 0.02;
    private static final double DISTANCE_THRESHOLD = 0.5; // Stop when within 0.5m

    public FollowAprilTagCommand(SwerveSubsystem swerveDrive) {
        this.swerveDrive = swerveDrive;
        addRequirements(swerveDrive);
    }

    @Override
    public void execute() {
        double[] botPose = LimelightHelpers.getBotPose(limelightName);

        if (botPose.length < 6) {
            swerveDrive.stop();
            return;
        }

        double tx = botPose[0]; // Forward/backward distance
        double ty = botPose[1]; // Left/right distance
        double yaw = botPose[5]; // Rotation to face tag

        // Stop if close enough
        if (Math.abs(tx) < DISTANCE_THRESHOLD) {
            swerveDrive.stop();
            return;
        }

        // PID-like control (tune kP values)
        double forwardSpeed = -tx * kP_translation;
        double strafeSpeed = -ty * kP_translation;
        double rotationSpeed = -yaw * kP_rotation;

        // Apply speed limits
        forwardSpeed = MathUtil.clamp(forwardSpeed, -1.0, 1.0);
        strafeSpeed = MathUtil.clamp(strafeSpeed, -1.0, 1.0);
        rotationSpeed = MathUtil.clamp(rotationSpeed, -1.0, 1.0);

        // Drive using YAGSL swerve
        swerveDrive.drive(new ChassisSpeeds(forwardSpeed, strafeSpeed, rotationSpeed));
    }

    @Override
    public void end(boolean interrupted) {
        swerveDrive.stop();
    }
}